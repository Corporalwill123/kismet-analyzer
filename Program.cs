namespace KismetAnalyzer;

using System.CommandLine;
using System.CommandLine.Builder;
using System.CommandLine.Parsing;

using UAssetAPI;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.PropertyTypes.Structs;
using UAssetAPI.Kismet.Bytecode;
using UAssetAPI.Kismet.Bytecode.Expressions;

using Dot;

public class Program {
    static int Main(string[] args) {
        var rootCommand = new RootCommand();

        var assetSource = new Argument<string>
            (name: "src",
            description: "Source asset");
        var assetDestination = new Argument<string>
            (name: "dest",
            description: "Destination asset");
        var importIndexes = new Argument<IList<int>>
            (name: "import indexes",
            description: "Import indexes");
        var assetInput = new Argument<string>
            (name: "input",
            description: "Path to asset");
        var assetInputDirectory = new Argument<string>
            (name: "input",
            description: "Path to asset input directory");
        var assetOutputDirectory = new Argument<string>
            (name: "output",
            description: "Path to asset output directory");
        var cfgOutputDiretory = new Argument<string>
            (name: "output",
            description: "Path to CFG output directory");
        var jsonOutputDiretory = new Argument<string>
            (name: "output",
            description: "Path to JSON output directory");
        var hierarchyOutput = new Argument<string>
            (name: "output",
            description: "Path to hierarchy output");
        var contextPath = new Argument<string>
            (name: "context",
            description: "Path to context JSON object generated by BPGen plugin (kismet.json in UE project directory)");

        var genCfg = new Command("gen-cfg", "Generate control flow graphs of single asset");
        genCfg.Add(assetInput);
        genCfg.Add(cfgOutputDiretory);
        genCfg.SetHandler(GenCfg, assetInput, cfgOutputDiretory);
        rootCommand.AddCommand(genCfg);

        var genCfgTree = new Command("gen-cfg-tree", "Generate control flow graphs of assets");
        genCfgTree.Add(assetInputDirectory);
        genCfgTree.Add(cfgOutputDiretory);
        genCfgTree.SetHandler(GenCfgTree, assetInputDirectory, cfgOutputDiretory);
        rootCommand.AddCommand(genCfgTree);

        var genJsonTree = new Command("get-json-tree", "Generate JSON representation of assets");
        genJsonTree.Add(assetInputDirectory);
        genJsonTree.Add(jsonOutputDiretory);
        genJsonTree.SetHandler(GenJsonTree, assetInputDirectory, jsonOutputDiretory);
        rootCommand.AddCommand(genJsonTree);

        var genBlueprint = new Command("gen-blueprint", "Generate blueprint asset");
        genBlueprint.Add(contextPath);
        genBlueprint.Add(assetSource);
        genBlueprint.Add(assetDestination);
        genBlueprint.SetHandler(GenBlueprint, contextPath, assetSource, assetDestination);
        rootCommand.AddCommand(genBlueprint);

        var genHierarchy = new Command("gen-hierarchy", "Generate a graph showing the class hierarchy of assets");
        genHierarchy.Add(assetInputDirectory);
        genHierarchy.Add(hierarchyOutput);
        genHierarchy.SetHandler(GenHierarchy, assetInputDirectory, hierarchyOutput);
        rootCommand.AddCommand(genHierarchy);

        var copyImports = new Command("copy-imports", "Copies imports from one asset to another and returns the new import indexes");
        copyImports.Add(assetSource);
        copyImports.Add(assetDestination);
        copyImports.Add(importIndexes);
        copyImports.SetHandler(CopyImports, assetSource, assetDestination, importIndexes);
        rootCommand.AddCommand(copyImports);

        var mergeFunctions = new Command("merge-functions",
@"Merge functions from source asset to the start of functions with matching names in the destination asset.
Leading underscores can be used to work around special function names being illegal in the editor.");
        mergeFunctions.Add(assetSource);
        mergeFunctions.Add(assetDestination);
        mergeFunctions.SetHandler(MergeFunctions, assetSource, assetDestination);
        rootCommand.AddCommand(mergeFunctions);

        var findSchematics = new Command("find-schematics", "Find all Deep Rock Galactic schematics");
        findSchematics.Add(assetInputDirectory);
        findSchematics.SetHandler(FindSchematics, assetInputDirectory);
        rootCommand.AddCommand(findSchematics);

        var makeModRemoveWeaponBobbing = new Command("make-mod-remove-weapon-bobbing", "Generate remove weapon bobbing assets");
        makeModRemoveWeaponBobbing.Add(assetInputDirectory);
        makeModRemoveWeaponBobbing.Add(assetOutputDirectory);
        makeModRemoveWeaponBobbing.SetHandler(MakeModRemoveWeaponBobbing, assetInputDirectory, assetOutputDirectory);
        rootCommand.AddCommand(makeModRemoveWeaponBobbing);

        var makeModRemoveAllParticles = new Command("make-mod-remove-all-particles", "Generate remove all particles assets");
        makeModRemoveAllParticles.SetHandler(MakeModRemoveAllParticles);
        rootCommand.AddCommand(makeModRemoveAllParticles);

        new CommandLineBuilder(rootCommand)
           .UseVersionOption()
           .UseHelp()
           .UseEnvironmentVariableDirective()
           .UseParseDirective()
           .UseSuggestDirective()
           .UseTypoCorrections()
           .UseParseErrorReporting()
           .UseExceptionHandler()
           .CancelOnProcessTermination()
           .Build()
           .Invoke(args);

        return 0;
    }
    static IEnumerable<string> GetAssets(string directory) {
        var enumOptions = new EnumerationOptions();
        enumOptions.IgnoreInaccessible = true;
        enumOptions.RecurseSubdirectories = true;
        return new[] { "*.uasset", "*.umap" }.SelectMany(pattern => Directory.EnumerateFiles(directory, pattern, enumOptions));
    }
    static void GenCfg(string assetPath, string outputDir) {
        UAsset asset = new UAsset(assetPath, UE4Version.VER_UE4_27);
        var fileName = Path.GetFileName(assetPath);
        var output = new StreamWriter(Path.Join(outputDir, Path.ChangeExtension(fileName, ".txt")));
        var dotOutput = new StreamWriter(Path.Join(outputDir, Path.ChangeExtension(fileName, ".dot")));
        new SummaryGenerator(asset, output, dotOutput).Summarize();
        output.Close();
        dotOutput.Close();
    }
    static void GenCfgTree(string input, string output) {
        foreach (var assetPath in GetAssets(input)) {
            var outputDir = Path.GetDirectoryName(Path.Join(output, Path.GetRelativePath(input, assetPath)));
            Directory.CreateDirectory(outputDir);
            GenCfg(assetPath, outputDir);
        }
    }
    static void GenJsonTree(string assetInputDir, string jsonOutputDir) {
        foreach (var assetPath in GetAssets(assetInputDir)) {
            var outputPath = Path.ChangeExtension(Path.Join(jsonOutputDir, Path.GetRelativePath(assetInputDir, assetPath)), ".json");

            var asset = new UAsset(assetPath, UE4Version.VER_UE4_27);

            string jsonSerializedAsset = new UAsset(assetPath, UE4Version.VER_UE4_27).SerializeJson(Newtonsoft.Json.Formatting.Indented);
            Console.WriteLine(outputPath);
            Directory.CreateDirectory(Path.GetDirectoryName(outputPath));
            File.WriteAllText(outputPath, jsonSerializedAsset);
        }
    }
    static void GenHierarchy(string assetInputDir, string hierarchyOutput) {
        var graph = new Graph("digraph");
        graph.GraphAttributes["rankdir"] = "LR";

        foreach (var assetPath in GetAssets(assetInputDir)) {
            var asset = new UAsset(assetPath, UE4Version.VER_UE4_27);
            var classExport = asset.GetClassExport();
            if (classExport != null) {
                var parent = classExport.SuperStruct.ToImport(asset);

                var assetPackage = Path.Join("/Game", Path.GetRelativePath(assetInputDir, Path.GetDirectoryName(assetPath)), Path.GetFileNameWithoutExtension(assetPath));
                //Console.WriteLine($"{assetPackage}.{classExport.ObjectName} : {parent.OuterIndex.ToImport(asset).ObjectName}.{parent.ObjectName}");
                var fullClassName = $"{assetPackage}.{classExport.ObjectName}";
                var fullParentName = $"{parent.OuterIndex.ToImport(asset).ObjectName}.{parent.ObjectName}";

                var classNode = new Node(fullClassName);
                classNode.Attributes["label"] = classExport.ObjectName.ToString();
                classNode.Attributes["URL"] = Path.Join("out/Content/", Path.GetRelativePath(assetInputDir, Path.GetDirectoryName(assetPath)), Path.ChangeExtension(Path.GetFileName(assetPath), ".svg"));
                graph.Nodes.Add(classNode);

                var edge = new Edge(fullClassName, fullParentName);
                graph.Edges.Add(edge);
            }
        }
        var output = new StreamWriter(hierarchyOutput);
        graph.Write(output);
        output.Close();
    }
    static void CopyImports(string assetSource, string assetDestination, IList<int> imports) {
        UAsset from = new UAsset(assetSource, UE4Version.VER_UE4_27);
        UAsset to = new UAsset(assetDestination, UE4Version.VER_UE4_27);

        foreach (var index in imports) {
            var newIndex = Kismet.CopyImportTo((from, FPackageIndex.FromRawIndex(index)), to);
            var i = newIndex.ToImport(to);
            Console.WriteLine($"Copied import {index} => {newIndex}: {i.ClassName}, {i.ClassPackage}, {i.ObjectName}");
        }

        to.Write(assetDestination);
    }
    static void MergeFunctions(string assetSource, string assetDestination) {
        UAsset source = new UAsset(assetSource, UE4Version.VER_UE4_27);
        UAsset dest = new UAsset(assetDestination, UE4Version.VER_UE4_27);
        foreach (var export in source.Exports) {
            if (export is FunctionExport fnSrc) {
                if (export.ObjectName.ToString().StartsWith("ExecuteUbergraph")) {
                    Console.Error.WriteLine("Ignoring ubergraph");
                    continue;
                }
                var found = false;
                foreach (var exportDest in dest.Exports) {
                    if (exportDest is FunctionExport fnDest) {
                        if (fnSrc.ObjectName.ToString().TrimStart('_') != fnDest.ObjectName.ToString().TrimStart('_')) continue;
                        Console.WriteLine($"Found matching function named {export.ObjectName}");

                        var newInst = new List<KismetExpression>();
                        //for (int i = 0; i < fnSrc.ScriptBytecode.Length; i++) {
                        var offset = 0;
                        var keepReturn = false;
                        foreach (var inst in fnSrc.ScriptBytecode) {
                            if (inst is EX_Context c) {
                                if (c.ContextExpression is EX_LocalVirtualFunction i) {
                                    if (i.VirtualFunctionName.Value.ToString() == "RETURN") {
                                        keepReturn = true;
                                        continue; // TODO handle offset addresses in source function because now we're skipping expressions
                                    }
                                }
                            }
                            var isReturn = inst.GetType() == typeof(EX_Return);
                            if (isReturn ? keepReturn : true) {
                                offset += (int) Kismet.GetSize(inst);
                                newInst.Add(Kismet.CopyExpressionTo(inst, source, dest, fnSrc, fnDest));
                            }
                            if (isReturn) break;
                        }
                        foreach (var inst in fnDest.ScriptBytecode) {
                            Kismet.ShiftAddressses(inst, offset);
                            newInst.Add(inst);
                        }
                        fnDest.ScriptBytecode = newInst.ToArray();

                        found = true;
                        break;
                    }
                }
                if (!found) Console.Error.WriteLine($"Could not find matching function for {fnSrc.ObjectName} in dest asset");
            }
        }
        dest.Write(assetDestination);
    }
    static void GenBlueprint(string contextPath, string assetSource, string assetDestination) {
        var context = UEContext.FromFile(contextPath);

        UAsset source = new UAsset(assetSource, UE4Version.VER_UE4_27);
        var generator = new BlueprintGenerator(context, source);
        generator.Generate();
    }

    static void FindSchematics(string assetInputDir) {
        foreach (var assetPath in GetAssets(assetInputDir)) {
            //var file = Path.GetFileName(assetPath);
            //if (!Path.GetFileName(assetPath).StartsWith("IAS_") || file == "IAS_Snowball.uasset") continue;

            UAsset asset = new UAsset(assetPath, UE4Version.VER_UE4_27);
            //Console.WriteLine(assetPath);
            foreach (var export in asset.Exports) {
                if (export.ClassIndex.IsImport() && export.ClassIndex.ToImport(asset).ObjectName.ToString() == "Schematic" && export is NormalExport e) {
                    Console.WriteLine($"{assetPath} {export.ObjectName}");
                    if (e["SaveGameID"] is StructPropertyData idStruct && idStruct.Value[0] is GuidPropertyData id) {
                        Console.WriteLine(id);
                    }
                    if (e["Item"] is ObjectPropertyData objData
                        && objData.IsExport() &&
                        objData.ToExport(asset) is NormalExport schematicItem) {
                        var type = schematicItem.ClassIndex.ToImport(asset).ObjectName.ToString();
                        switch (type.ToString()) {
                            case "SkinSchematicItem":
                            {
                                if (schematicItem["Skin"] is ObjectPropertyData skinData) {
                                    if (skinData.IsExport()) {
                                        //var item3 = skinData.ToExport(asset);
                                        //Console.WriteLine($"{item3.ObjectName}");
                                    } else if (skinData.IsImport()) {
                                        //var item3 = skinData.ToImport(asset);
                                        //Console.WriteLine($"{item3.ObjectName}");
                                    } else {
                                        throw new NotImplementedException("Expected import");
                                    }
                                } else {
                                    throw new NotImplementedException("No ObjectPropertyData \"Skin\"");
                                }
                                break;
                            }
                            case "VanitySchematicItem":
                            {
                                if (schematicItem["Item"] is ObjectPropertyData vanityData) {
                                    if (vanityData.IsExport() && vanityData.ToExport(asset) is NormalExport vanityItem) {
                                        if (vanityItem["ItemName"] is TextPropertyData txt) {
                                            Console.WriteLine(txt.CultureInvariantString);
                                        } else {
                                            throw new NotImplementedException("Expected TextPropertyData");
                                        }
                                    } else if (vanityData.IsImport()) {
                                        //throw new NotImplementedException("Expected export");
                                        //var item3 = vanityData.ToImport(asset);
                                        //Console.WriteLine($"{item3.ObjectName}");
                                    } else {
                                        throw new NotImplementedException("Expected import");
                                    }
                                } else {
                                    throw new NotImplementedException("No ObjectPropertyData \"Item\"");
                                }
                                break;
                            }
                            case "OverclockShematicItem":
                            {
                                break;
                            }
                            case "ResourceSchematicItem":
                            {
                                break;
                            }
                            case "VictoryPoseSchematicItem":
                            {
                                break;
                            }
                            case "BlankSchematicItem":
                            {
                                break;
                            }
                            default:
                            {
                                throw new NotImplementedException($"Unknown schematic type {type}");
                            }
                        }
                    } else {
                        throw new NotImplementedException("Expected import");
                    }
                }
            }
        }
    }

    static void MakeModRemoveWeaponBobbing(string assetInputDirectory, string assetOutputDirectory) {
        List<string> fpNames = new List<string> {
            //"FP_Idle",
            //"FP_InspectWeapon",
            //"FP_Walk",
            //"FP_Sprint",
            "FP_JumpStart",
            "FP_JumpLoop",
            "FP_JumpLand",
            "FP_JumpLand_Aim",
            //"FP_Downed",
        };
        HashSet<(string, string)> animations = new HashSet<(string, string)>();
        foreach (var assetPath in GetAssets(assetInputDirectory)) {
            var file = Path.GetFileName(assetPath);
            if (!Path.GetFileName(assetPath).StartsWith("IAS_") || file == "IAS_Snowball.uasset") continue;
            var outputPath = Path.Join(assetOutputDirectory, Path.GetRelativePath(assetInputDirectory, assetPath));

            UAsset asset = new UAsset(assetPath, UE4Version.VER_UE4_27);
            Console.WriteLine(assetPath);
            foreach (var export in asset.Exports) {
                if (export.ClassIndex.IsImport() && export.ClassIndex.ToImport(asset).ObjectName.ToString() == "ItemCharacterAnimationSet" && export is NormalExport e) {
                    Console.WriteLine(export.ObjectName);

                    Dictionary<string, ObjectPropertyData> props = new Dictionary<string, ObjectPropertyData>();

                    foreach (var prop in e.Data) {
                        var name = prop.Name.ToString();
                        if (prop is ObjectPropertyData anim) {
                            props[name] = anim;
                            if (fpNames.Contains(name)) {
                                var path = Path.Join(assetInputDirectory, Path.GetRelativePath("/Game", anim.Value.ToImport(asset).OuterIndex.ToImport(asset).ObjectName + ".uasset"));
                                animations.Add((path, prop.Name.ToString()));
                            }
                        }
                    }
                    //if (props.ContainsKey("FP_Walk") && props.ContainsKey("FP_Sprint"))
                        //props["FP_Walk"].Value = props["FP_Sprint"].Value;

                    /*
                    if (fpWalk != null) {
                        foreach (var prop in e.Data) {
                            if (fpNames.Contains(prop.Name.ToString()) && prop is ObjectPropertyData anim) {
                                anim.Value = fpWalk;
                            }
                        }
                    }
                    */
                    break;
                }
            }

            Directory.CreateDirectory(Path.GetDirectoryName(outputPath));
            asset.Write(outputPath);
            Console.WriteLine(outputPath);
        }

        foreach (var (assetPath, animationType) in animations) {
            var outputPath = Path.Join(assetOutputDirectory, Path.GetRelativePath(assetInputDirectory, assetPath));

            UAsset asset = new UAsset(assetPath, UE4Version.VER_UE4_27);
            string? type = null;
            foreach (var export in asset.Exports) {
                if (export.ClassIndex.IsImport() && export.ClassIndex.ToImport(asset).ObjectName.ToString() == "AnimSequence" && export is NormalExport e) {
                    foreach (var prop in e.Data) {
                        if (prop.Name.ToString() == "NumFrames" && prop is IntPropertyData numFrames) {
                            //numFrames.Value = 1;
                        }
                        if (prop.Name.ToString() == "SequenceLength" && prop is FloatPropertyData sequenceLength) {
                            if (animationType == "FP_JumpLand") {
                                sequenceLength.Value = 0.01f;
                            } else {
                                sequenceLength.Value = 999999999999;
                            }
                        }
                        if (prop.Name.ToString() == "Skeleton" && prop is ObjectPropertyData skeleton) {
                            type = skeleton.Value.ToImport(asset).ObjectName.ToString();
                            //sequenceLength.Value = 0;
                        }
                    }
                    break;
                }
            }
            if (type == "1P_Dwarf_Rig_Skeleton") {
                Directory.CreateDirectory(Path.GetDirectoryName(outputPath));
                asset.Write(outputPath);
                Console.WriteLine(outputPath);
            }

            //Directory.CreateDirectory(Path.GetDirectoryName(outputPath));
            //var asset = new UAsset(assetPath, UE4Version.VER_UE4_27);
        }
    }

    static void MakeModRemoveAllParticles() {
        UAsset particleAsset = new UAsset("../../FSD/Saved/Cooked/LinuxNoEditor/FSD/Content/_Tests/Dummy/EmptyParticleSystem.uasset", UE4Version.VER_UE4_27);
        int particleAssetNameIndex = particleAsset.SearchNameReference(new FString("EmptyParticleSystem"));
        int particleAssetPathIndex = particleAsset.SearchNameReference(new FString("/Game/_Tests/Dummy/EmptyParticleSystem"));
        UAsset niagaraAsset = new UAsset("../../FSD/Saved/Cooked/LinuxNoEditor/FSD/Content/_Tests/Dummy/EmptyNiagaraSystem.uasset", UE4Version.VER_UE4_27);
        int niagaraAssetNameIndex = niagaraAsset.SearchNameReference(new FString("EmptyNiagaraSystem"));
        int niagaraAssetPathIndex = niagaraAsset.SearchNameReference(new FString("/Game/_Tests/Dummy/EmptyNiagaraSystem"));

        string[] exclusions = {
            "Content/Critters/FesterFlea/Flea/P_Flea_Trail",
            "Content/Art/Particles/ActorFX/P_GreenMaggot_PoisonCloud",
            "Content/Art/Particles/ActorFX/Spawning/P_SpawnCloud_Large",
            "Content/Art/Particles/P_Geyser_EruptAir",
            "Content/Enemies/Spider/Spitter/P_SpittingSpiderProjectile_A",
            "Content/Enemies/Spider/Shooter/P_SpiderShooterProjectile_A",
            "Content/Enemies/Spider/Tank/Particles/P_RadioActive_Cloud",
            "Content/Enemies/Spider/RapidShooter/P_Spider_RapidShooterProjectile_A",
            "Content/Enemies/Spider/Particles/P_Spider_Tank_AcidFlame",
            "Content/Enemies/Spider/Particles/P_Spider_TankIce_Shoot",
            "Content/Enemies/Spider/Particles/P_Spider_Tank_DeathCloud",
            "Content/Enemies/Spider/Particles/P_Spider_TankIce_DeathCloud",
            "Content/Enemies/Plague/Particles/NS_Plague_Spider_Tank_DeathCloud",
            "Content/Enemies/Plague/Particles/NS_Plague_Projectile_Trail",
            "Content/Enemies/Spider/Tank/Particles/P_RadioActive_Cloud",
            "Content/Enemies/Spider/Tank/Particles/P_RadioActive_Cloud_Medium",
            "Content/Enemies/Spider/Particles/P_Spider_BarrageAttack_A",
            "Content/Enemies/Spider/Particles/P_Spider_Tank_DeathCloud",
            "Content/Enemies/Spider/Particles/P_Spider_TankPlague_Shoot",
            "Content/Enemies/Spider/TankBoss/BossTank/P_Spider_Boss_ShootTrail",
            "Content/Enemies/Spider/TankBoss/BossHeavy/Particles/NS_Rock_Projectile",
            "Content/Enemies/Spider/TankBoss/BossHeavy/Particles/P_SentinelGoo_AOEpuddle",
            "Content/Enemies/Spider/TankBoss/BossTwins/P_Spider_BossTwin_SmallShootTrail",
            "Content/Enemies/Spider/TankBoss/BossTwins/Particles/NS_Twin_Fire_Breath",
            "Content/Enemies/Spider/TankBoss/BossTwins/Particles/NS_Stomp_Wave",
            "Content/Enemies/Spider/TankBoss/BossTwins/P_TwinA_Mine_AreaAttackWindup",
            "Content/Enemies/Spider/TankBoss/BossTwins/P_Spider_BossTwin_Explosion",
            "Content/Enemies/Spider/TankBoss/BossTwins/P_TwinA_Mine_AreaAttack",
            "Content/Enemies/Spider/TankBoss/BossTank/P_Spider_Boss_AreaAttack_B",
            "Content/Enemies/FlyingBug/Bomber/P_BomberGoo_AOEpuddle",
            "Content/Enemies/FlyingBug/Bomber/P_BomberIce_AOEpuddle",
            "Content/Enemies/Woodlouse/Particles/P_WoodLouse_Projectile",
            "Content/LevelElements/RoomObjects/Hazards/InsectSwarm/P_InsectSwarm_A",
            "Content/Landscape/Biomes/Biomes_Ingame/HollowBough/WaspNest/P_InsectSwarm_Showroom",
            "Content/GameElements/Missions/Warnings/HeroEnemies/Particle_Effects/NS_HeroEnemy_Beacon_Constant_Big",
            "Content/GameElements/Missions/Warnings/HeroEnemies/Particle_Effects/NS_HeroEnemy_Beacon_Constant",
            "Content/GameElements/Missions/Warnings/Plague/CleaningPod/Soaper/NS_Foam_Projectile",
            "Content/GameElements/Missions/Warnings/Plague/CleaningPod/Soaper/NS_Foam_Puddle",
            "Content/Enemies/HydraWeed/Particles/P_HealerSeed_Trail",
            "Content/Enemies/HydraWeed/Particles/P_ShooterSeed_Trail",
            "Content/GameElements/Objectives/Facility/DefenseTurret/P_FacilityTurret_Sniperbeam",
            "Content/GameElements/Objectives/Facility/NS_Facility_Projectile_Power_Sniper",
            "Content/GameElements/Objectives/Facility/NS_Facility_Projectile",
            "Content/GameElements/Objectives/Facility/NS_Facility_Projectile",
            "Content/GameElements/Objectives/Facility/NS_Facility_Projectile_Power",
            "Content/GameElements/Objectives/Facility/DefensiveTentacles/NS_Defence_Tentacle_Projectile",
            "Content/Enemies/Spider/ExploderTank/P_ExploderTank_CollectingEmbers",
            "Content/Enemies/Spider/ExploderTank/P_GhostTank_CollectingEmbers",
            "Content/Enemies/Spider/Particles/P_SpiderExploderTank_Footstep",
            "Content/LevelElements/RoomObjects/Hazards/StickyGoo/P_StickyGoo",
            "Content/LevelElements/RoomObjects/Hazards/PoisonGasFungus/P_PoisonGasFungus_PoisonCloud",
            "Content/LevelElements/RoomObjects/Hazards/LavaGeyser/P_Geyser_EruptLava_Small_Tell",
            "Content/LevelElements/RoomObjects/Hazards/ExplodingGooPlant/P_ExplodingGooPlant_AOEpuddle",
            "Content/LevelElements/RoomObjects/Hazards/SandGeyser/P_Geyser_Sand_Errupt_Outside",
            "Content/LevelElements/RoomObjects/Hazards/SandGeyser/P_Geyser_Sand_Inside-Idle",
            "Content/LevelElements/RoomObjects/Hazards/FrostGeyser/P_Geyser_Frost_Errupt_Outside",
            "Content/LevelElements/RoomObjects/Hazards/FrostGeyser/P_Geyser_Frost_Inside-Idle",
            "Content/LevelElements/RoomObjects/Hazards/ElectricPlant/Particles/P_ElectroPlantBeam",
            "Content/LevelElements/Refinery/LiquidMorkite_Well/P_LiquidMorkite_Well",
            "Content/GameElements/Objectives/Escort/FlyingSmartRocks/P_Heartstone_ConnectionLine",
            "Content/GameElements/Objectives/Facility/Tethers/NS_Teather_Beam",
            "Content/GameElements/PawnAffliction/EnemyEffects/Burning/P_Burning_Huge",
            "Content/GameElements/PawnAffliction/EnemyEffects/Burning/P_Burning_Large",
            "Content/GameElements/PawnAffliction/EnemyEffects/Burning/P_Burning_Medium",
            "Content/GameElements/PawnAffliction/EnemyEffects/Burning/P_Burning_Small",
            "Content/GameElements/PawnAffliction/EnemyEffects/Poisoned/P_PoisonedEnemy_Medium",
            "Content/GameElements/PawnAffliction/EnemyEffects/Poisoned/P_PoisonedEnemy_Tiny",
            "Content/GameElements/PawnAffliction/EnemyEffects/Eletrocuted/P_State_Electrocute_2Mid",
            "Content/GameElements/PawnAffliction/EnemyEffects/Regenerating/P_RegenrativeEnemies_FX",
            "Content/GameElements/Drone/P_Drone_Tracer",
            "Content/GameElements/Drone/P_Bosco_Rocket_Trail",
            "Content/WeaponsNTools/Extractor/P_OilExtractor_BeamActive",
            "Content/WeaponsNTools/Extractor/P_OilExtractor_BeamInactive",
            "Content/WeaponsNTools/SentryGun/P_Sentry_Tracer",
            "Content/WeaponsNTools/SentryGun/SentryGun_Engineer/P_OverchargeProjectile_Trail",
            "Content/Enemies/Spider/Tank/Particles/P_RadioActive_Cloud_Large",
            "Content/WeaponsNTools/LineCutter/Particles/P_Plasma_Projectile",
            "Content/WeaponsNTools/LineCutter/Particles/P_PlasmaBeam_PlasmaTrailSegment",
            "Content/WeaponsNTools/SentryGun/P_ElectrocutedTurret",
            "Content/GameElements/GameEvents/AmberEvent/Particles/P_AmberEvent_Explosion",
            "Content/WeaponsNTools/ChargeBlaster/Particles/P_ChargedProjectileExplodeBig",
            "Content/WeaponsNTools/ChargeBlaster/Particles/P_ChargedProjectile_Persistance",
            "Content/WeaponsNTools/ChargeBlaster/Particles/P_UPG_Charged_AOE",
            "Content/WeaponsNTools/FlameThrower/Particles/P_WPN_Environment_StickyFlame",
            "Content/WeaponsNTools/FlameThrower/Particles/P_WPN_Flamethrower_Plume_1stPerson",
            "Content/WeaponsNTools/FlameThrower/Particles/P_UPG_Flamethrower_HighPressure_1stPerson_New",
            "Content/WeaponsNTools/FlameThrower/Particles/P_UPG_Flamethrower_VeryHighPressure_1stPerson",
            "Content/WeaponsNTools/Cryospray/Particles/P_WPN_Cryospray_Impact",
            "Content/WeaponsNTools/Cryospray/Particles/P_WPN_Cryospray_1stPerson",
            "Content/WeaponsNTools/Cryospray/Particles/P_WPN_Cryospray_3rdPerson",
            "Content/WeaponsNTools/Cryospray/Particles/P_WPN_Environment_StickyFrost",
            "Content/WeaponsNTools/Grenades/Neurotoxin/P_Grenade_Neurotoxin_Cloud",
            "Content/WeaponsNTools/GooCannon/Particles/NS_Goo_Projectile",
            "Content/WeaponsNTools/GooCannon/Particles/NS_Goo_Puddle",
            "Content/WeaponsNTools/GooCannon/Particles/NS_GooCannon_DoT",
            "Content/WeaponsNTools/GooCannon/Particles/NS_GooCannon_DoT_Large",
            "Content/WeaponsNTools/GooCannon/Particles/NS_GooCannon_DoT_XLarge",
            "Content/WeaponsNTools/Autocannon/Particles/NS_AutoCannon_ShotImpact",
            "Content/WeaponsNTools/Grenades/Incendiary/P_Grenade_Incendiary_Flames",
            "Content/WeaponsNTools/Grenades/IFG/P_Grenade_IFG_Explosion_A_AttemptingGFXfix",
            "Content/WeaponsNTools/Grenades/ParasiteGrenade/NS_Grenade_Parasites_Explosion",
            "Content/WeaponsNTools/Grenades/Pheromone/P_Grenade_Pheromone_Soaked",
            "Content/WeaponsNTools/PlasmaCarbine/Particles/NS_PlasmaCarbine_Projectile",
            "Content/WeaponsNTools/Crossbow/Particles/NS_Crossbow_Bodkin",
            "Content/WeaponsNTools/Crossbow/Particles/",
            "Content/Art/Environments/Holiday_Halloween/",
            "Content/Art/Environments/Holiday_Xmas/",
            "Content/Art/Environments/SpaceRig/",
            "Content/Art/Environments/SpaceRig_Exterior/",
            "Content/GameElements/Bar/",
            "Content/CharacterStructure/Forge/",
            "Content/Character/",
            "Content/CharacterStructure/Gear_Unarmed/TP/EndScreenAnims/Attachments/",
            "Content/Enemies/Spider/Exploder/P_BarrelExplosion",
            "Content/Enemies/Spider/Buffer/p_BufferArc",
            "Content/Enemies/HydraWeed/Particles/p_HydraWeed_BuffLine",
            "Content/WeaponsNTools/CoilGun/Assets/Particles/P_WPN_Environment_Coilgun_StickyFlame",
            "Content/WeaponsNTools/CoilGun/Assets/Particles/NS_CoilGun_Multi_Trail",
            "Content/WeaponsNTools/Autocannon/Overclocks/OC_BonusesAndPenalties/NS_OC_NeuroToxin_Payload",
            "Content/WeaponsNTools/HeavyParticleCannon/Particles/NS_HPC_Volatile_Impact_Reactor",
        };
        string[] weaponsntools = {
            "Content/WeaponsNTools/",
            "Content/GameElements/Drone/",
        };
        var unmatched = new HashSet<string>(exclusions);

        var FSDPath = "../../unpacked-exp/FSD";
        var OutputRemoveParticles = "../../unpacked-mods/remove-all-particles";
        var OutputRemoveParticlesButWeaponsNTools = "../../unpacked-mods/remove-all-particles-but-weaponsntools";
        try { Directory.Delete(OutputRemoveParticles, true); } catch {}
        try { Directory.Delete(OutputRemoveParticlesButWeaponsNTools, true); } catch {}

        foreach (var assetPath in GetAssets(FSDPath)) {
            var relPath = Path.GetRelativePath(FSDPath, Path.ChangeExtension(assetPath, null));

            var exclude = false;
            foreach (var ex in exclusions) {
                if (relPath.StartsWith(ex)) {
                    unmatched.Remove(ex);
                    exclude = true;
                    // cannot break out early as some exclusions won't match and will cause a warning
                }
            }
            if (exclude) {
                continue;
            }

            UAsset asset = new UAsset(assetPath, UE4Version.VER_UE4_27);
            foreach (var export in asset.Exports) {
                if (export.ClassIndex.IsImport()) {
                    var assetType = export.ClassIndex.ToImport(asset).ObjectName.ToString();

                    var name = Path.GetFileNameWithoutExtension(assetPath);
                    var path = Path.Combine("/Game/Content/", relPath);
                    UAsset? empty = null;
                    if (assetType == "ParticleSystem") {
                        empty = particleAsset;
                        empty.SetNameReference(particleAssetNameIndex, new FString(name));
                        empty.SetNameReference(particleAssetPathIndex, new FString(path));
                    } else if (assetType == "NiagaraSystem") {
                        empty = niagaraAsset;
                        empty.SetNameReference(niagaraAssetNameIndex, new FString(name));
                        empty.SetNameReference(niagaraAssetPathIndex, new FString(path));
                    }

                    if (empty != null) {
                        var withExtension = $"{relPath}.uasset";

                        var outPath = Path.Join(OutputRemoveParticles, withExtension);
                        Directory.CreateDirectory(Path.GetDirectoryName(outPath));
                        empty.Write(outPath);

                        var excludeWNT = false;
                        foreach (var ex in weaponsntools) {
                            if (relPath.StartsWith(ex)) {
                                excludeWNT = true;
                            }
                        }
                        if (!excludeWNT) {
                            var outPathWNT = Path.Join(OutputRemoveParticlesButWeaponsNTools, withExtension);
                            Directory.CreateDirectory(Path.GetDirectoryName(outPathWNT));
                            empty.Write(outPathWNT);
                        }

                        break;
                    }
                }
            }
        }

        foreach (var ex in unmatched) {
            Console.Error.WriteLine($"WARNING: Exclusion {ex} did not have any matches");
        }
    }
}
